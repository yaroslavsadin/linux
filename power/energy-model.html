

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Energy Model of devices &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Freezing of tasks" href="freezing-of-tasks.html" />
    <link rel="prev" title="Testing suspend and resume support in device drivers" href="drivers-testing.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.16.0-rc1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Power Management</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="apm-acpi.html">APM or ACPI?</a></li>
<li class="toctree-l2"><a class="reference internal" href="basic-pm-debugging.html">Debugging hibernation and suspend</a></li>
<li class="toctree-l2"><a class="reference internal" href="charger-manager.html">Charger Manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="drivers-testing.html">Testing suspend and resume support in device drivers</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Energy Model of devices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">1. Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#core-apis">2. Core APIs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#config-options">2.1 Config options</a></li>
<li class="toctree-l4"><a class="reference internal" href="#registration-of-performance-domains">2.2 Registration of performance domains</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accessing-performance-domains">2.3 Accessing performance domains</a></li>
<li class="toctree-l4"><a class="reference internal" href="#description-details-of-this-api">2.4 Description details of this API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#example-driver">3. Example driver</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="freezing-of-tasks.html">Freezing of tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="opp.html">Operating Performance Points (OPP) Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html">PCI Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm_qos_interface.html">PM Quality Of Service Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="power_supply_class.html">Linux power supply class</a></li>
<li class="toctree-l2"><a class="reference internal" href="runtime_pm.html">Runtime Power Management Framework for I/O Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="s2ram.html">How to get s2ram working</a></li>
<li class="toctree-l2"><a class="reference internal" href="suspend-and-cpuhotplug.html">Interaction of Suspend code (S3) with the CPU hotplug infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="suspend-and-interrupts.html">System Suspend and Device Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="swsusp-and-swap-files.html">Using swap files with software suspend (swsusp)</a></li>
<li class="toctree-l2"><a class="reference internal" href="swsusp-dmcrypt.html">How to use dm-crypt and swsusp together</a></li>
<li class="toctree-l2"><a class="reference internal" href="swsusp.html">Swap suspend</a></li>
<li class="toctree-l2"><a class="reference internal" href="video.html">Video issues with S3 resume</a></li>
<li class="toctree-l2"><a class="reference internal" href="tricks.html">swsusp/S3 tricks</a></li>
<li class="toctree-l2"><a class="reference internal" href="userland-swsusp.html">Documentation for userland software suspend interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="powercap/powercap.html">Power Capping Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="powercap/dtpm.html">Dynamic Thermal Power Management framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator/consumer.html">Regulator Consumer Driver Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator/design.html">Regulator API design notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator/machine.html">Regulator Machine Driver Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator/overview.html">Linux voltage and current regulator framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator/regulator.html">Regulator Driver Interface</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Power Management</a> &raquo;</li>
        
      <li>Energy Model of devices</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/power/energy-model.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="energy-model-of-devices">
<h1>Energy Model of devices<a class="headerlink" href="#energy-model-of-devices" title="Permalink to this headline">¶</a></h1>
<section id="overview">
<h2>1. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The Energy Model (EM) framework serves as an interface between drivers knowing
the power consumed by devices at various performance levels, and the kernel
subsystems willing to use that information to make energy-aware decisions.</p>
<p>The source of the information about the power consumed by devices can vary greatly
from one platform to another. These power costs can be estimated using
devicetree data in some cases. In others, the firmware will know better.
Alternatively, userspace might be best positioned. And so on. In order to avoid
each and every client subsystem to re-implement support for each and every
possible source of information on its own, the EM framework intervenes as an
abstraction layer which standardizes the format of power cost tables in the
kernel, hence enabling to avoid redundant work.</p>
<p>The power values might be expressed in milli-Watts or in an ‘abstract scale’.
Multiple subsystems might use the EM and it is up to the system integrator to
check that the requirements for the power value scale types are met. An example
can be found in the Energy-Aware Scheduler documentation
<a class="reference internal" href="../scheduler/sched-energy.html"><span class="doc">Energy Aware Scheduling</span></a>. For some subsystems like thermal or
powercap power values expressed in an ‘abstract scale’ might cause issues.
These subsystems are more interested in estimation of power used in the past,
thus the real milli-Watts might be needed. An example of these requirements can
be found in the Intelligent Power Allocation in
<a class="reference internal" href="../driver-api/thermal/power_allocator.html"><span class="doc">Power allocator governor tunables</span></a>.
Kernel subsystems might implement automatic detection to check whether EM
registered devices have inconsistent scale (based on EM internal flag).
Important thing to keep in mind is that when the power values are expressed in
an ‘abstract scale’ deriving real energy in milli-Joules would not be possible.</p>
<p>The figure below depicts an example of drivers (Arm-specific here, but the
approach is applicable to any architecture) providing power costs to the EM
framework, and interested clients reading the data from it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>+---------------+  +-----------------+  +---------------+
| Thermal (IPA) |  | Scheduler (EAS) |  |     Other     |
+---------------+  +-----------------+  +---------------+
        |                   | em_cpu_energy()   |
        |                   | em_cpu_get()      |
        +---------+         |         +---------+
                  |         |         |
                  v         v         v
                 +---------------------+
                 |    Energy Model     |
                 |     Framework       |
                 +---------------------+
                    ^       ^       ^
                    |       |       | em_dev_register_perf_domain()
         +----------+       |       +---------+
         |                  |                 |
 +---------------+  +---------------+  +--------------+
 |  cpufreq-dt   |  |   arm_scmi    |  |    Other     |
 +---------------+  +---------------+  +--------------+
         ^                  ^                 ^
         |                  |                 |
 +--------------+   +---------------+  +--------------+
 | Device Tree  |   |   Firmware    |  |      ?       |
 +--------------+   +---------------+  +--------------+
</pre></div>
</div>
<p>In case of CPU devices the EM framework manages power cost tables per
‘performance domain’ in the system. A performance domain is a group of CPUs
whose performance is scaled together. Performance domains generally have a
1-to-1 mapping with CPUFreq policies. All CPUs in a performance domain are
required to have the same micro-architecture. CPUs in different performance
domains can have different micro-architectures.</p>
</section>
<section id="core-apis">
<h2>2. Core APIs<a class="headerlink" href="#core-apis" title="Permalink to this headline">¶</a></h2>
<section id="config-options">
<h3>2.1 Config options<a class="headerlink" href="#config-options" title="Permalink to this headline">¶</a></h3>
<p>CONFIG_ENERGY_MODEL must be enabled to use the EM framework.</p>
</section>
<section id="registration-of-performance-domains">
<h3>2.2 Registration of performance domains<a class="headerlink" href="#registration-of-performance-domains" title="Permalink to this headline">¶</a></h3>
<p>Drivers are expected to register performance domains into the EM framework by
calling the following API:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int em_dev_register_perf_domain(struct device *dev, unsigned int nr_states,
              struct em_data_callback *cb, cpumask_t *cpus, bool milliwatts);
</pre></div>
</div>
<p>Drivers must provide a callback function returning &lt;frequency, power&gt; tuples
for each performance state. The callback function provided by the driver is free
to fetch data from any relevant location (DT, firmware, …), and by any mean
deemed necessary. Only for CPU devices, drivers must specify the CPUs of the
performance domains using cpumask. For other devices than CPUs the last
argument must be set to NULL.
The last argument ‘milliwatts’ is important to set with correct value. Kernel
subsystems which use EM might rely on this flag to check if all EM devices use
the same scale. If there are different scales, these subsystems might decide
to: return warning/error, stop working or panic.
See Section 3. for an example of driver implementing this
callback, or Section 2.4 for further documentation on this API</p>
</section>
<section id="accessing-performance-domains">
<h3>2.3 Accessing performance domains<a class="headerlink" href="#accessing-performance-domains" title="Permalink to this headline">¶</a></h3>
<p>There are two API functions which provide the access to the energy model:
<a class="reference internal" href="#c.em_cpu_get" title="em_cpu_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">em_cpu_get()</span></code></a> which takes CPU id as an argument and <a class="reference internal" href="#c.em_pd_get" title="em_pd_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">em_pd_get()</span></code></a> with device
pointer as an argument. It depends on the subsystem which interface it is
going to use, but in case of CPU devices both functions return the same
performance domain.</p>
<p>Subsystems interested in the energy model of a CPU can retrieve it using the
<a class="reference internal" href="#c.em_cpu_get" title="em_cpu_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">em_cpu_get()</span></code></a> API. The energy model tables are allocated once upon creation of
the performance domains, and kept in memory untouched.</p>
<p>The energy consumed by a performance domain can be estimated using the
<a class="reference internal" href="#c.em_cpu_energy" title="em_cpu_energy"><code class="xref c c-func docutils literal notranslate"><span class="pre">em_cpu_energy()</span></code></a> API. The estimation is performed assuming that the schedutil
CPUfreq governor is in use in case of CPU device. Currently this calculation is
not provided for other type of devices.</p>
<p>More details about the above APIs can be found in <code class="docutils literal notranslate"><span class="pre">&lt;linux/energy_model.h&gt;</span></code>
or in Section 2.4</p>
</section>
<section id="description-details-of-this-api">
<h3>2.4 Description details of this API<a class="headerlink" href="#description-details-of-this-api" title="Permalink to this headline">¶</a></h3>
<dl class="c struct">
<dt id="c.em_perf_state">
<em class="property"><span class="pre">struct</span> </em><code class="sig-name descname"><span class="pre">em_perf_state</span></code><a class="headerlink" href="#c.em_perf_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Performance state of a performance domain</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct em_perf_state {
  unsigned long frequency;
  unsigned long power;
  unsigned long cost;
  unsigned long flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">frequency</span></code></dt><dd><p>The frequency in KHz, for consistency with CPUFreq</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">power</span></code></dt><dd><p>The power consumed at this level (by 1 CPU or by a registered
device). It can be a total power: static and dynamic.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cost</span></code></dt><dd><p>The cost coefficient associated with this level, used during
energy calculation. Equal to: power * max_frequency / frequency</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>see “em_perf_state flags” description below.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.em_perf_domain">
<em class="property"><span class="pre">struct</span> </em><code class="sig-name descname"><span class="pre">em_perf_domain</span></code><a class="headerlink" href="#c.em_perf_domain" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Performance domain</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct em_perf_domain {
  struct em_perf_state *table;
  int nr_perf_states;
  unsigned long flags;
  unsigned long cpus[];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">table</span></code></dt><dd><p>List of performance states, in ascending order</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">nr_perf_states</span></code></dt><dd><p>Number of performance states</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>See “em_perf_domain flags”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpus</span></code></dt><dd><p>Cpumask covering the CPUs of the domain. It’s here
for performance reasons to avoid potential cache
misses during energy calculations in the scheduler
and simplifies allocating/freeing that memory region.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>In case of CPU device, a “performance domain” represents a group of CPUs
whose performance is scaled together. All CPUs of a performance domain
must have the same micro-architecture. Performance domains often have
a 1-to-1 mapping with CPUFreq policies. In case of other devices the <strong>cpus</strong>
field is unused.</p>
<dl class="c function">
<dt id="c.em_pd_get_efficient_state">
<em class="property"><span class="pre">struct</span></em> <a class="reference internal" href="#c.em_perf_state" title="em_perf_state"><span class="pre">em_perf_state</span></a> <span class="pre">*</span><code class="sig-name descname"><span class="pre">em_pd_get_efficient_state</span></code><span class="sig-paren">(</span><em class="property"><span class="pre">struct</span></em> <a class="reference internal" href="#c.em_perf_domain" title="em_perf_domain"><span class="pre">em_perf_domain</span></a> <span class="pre">*</span><em><span class="pre">pd</span></em>, <span class="pre">unsigned</span> <span class="pre">long</span> <em><span class="pre">freq</span></em><span class="sig-paren">)</span><a class="headerlink" href="#c.em_pd_get_efficient_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get an efficient performance state from the EM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_perf_domain</span> <span class="pre">*pd</span></code></dt><dd><p>Performance domain for which we want an efficient frequency</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">freq</span></code></dt><dd><p>Frequency to map with the EM</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is called from the scheduler code quite frequently and as a consequence
doesn’t implement any check.</p>
<p><strong>Return</strong></p>
<p>An efficient performance state, high enough to meet <strong>freq</strong>
requirement.</p>
<dl class="c function">
<dt id="c.em_cpu_energy">
<span class="pre">unsigned</span> <span class="pre">long</span> <code class="sig-name descname"><span class="pre">em_cpu_energy</span></code><span class="sig-paren">(</span><em class="property"><span class="pre">struct</span></em> <a class="reference internal" href="#c.em_perf_domain" title="em_perf_domain"><span class="pre">em_perf_domain</span></a> <span class="pre">*</span><em><span class="pre">pd</span></em>, <span class="pre">unsigned</span> <span class="pre">long</span> <em><span class="pre">max_util</span></em>, <span class="pre">unsigned</span> <span class="pre">long</span> <em><span class="pre">sum_util</span></em>, <span class="pre">unsigned</span> <span class="pre">long</span> <em><span class="pre">allowed_cpu_cap</span></em><span class="sig-paren">)</span><a class="headerlink" href="#c.em_cpu_energy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Estimates the energy consumed by the CPUs of a performance domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_perf_domain</span> <span class="pre">*pd</span></code></dt><dd><p>performance domain for which energy has to be estimated</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max_util</span></code></dt><dd><p>highest utilization among CPUs of the domain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">sum_util</span></code></dt><dd><p>sum of the utilization of all CPUs in the domain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">allowed_cpu_cap</span></code></dt><dd><p>maximum allowed CPU capacity for the <strong>pd</strong>, which
might reflect reduced frequency (due to thermal)</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be used only for CPU devices. There is no validation,
i.e. if the EM is a CPU type and has cpumask allocated. It is called from
the scheduler code quite frequently and that is why there is not checks.</p>
<p><strong>Return</strong></p>
<p>the sum of the energy consumed by the CPUs of the domain assuming
a capacity state satisfying the max utilization of the domain.</p>
<dl class="c function">
<dt id="c.em_pd_nr_perf_states">
<span class="pre">int</span> <code class="sig-name descname"><span class="pre">em_pd_nr_perf_states</span></code><span class="sig-paren">(</span><em class="property"><span class="pre">struct</span></em> <a class="reference internal" href="#c.em_perf_domain" title="em_perf_domain"><span class="pre">em_perf_domain</span></a> <span class="pre">*</span><em><span class="pre">pd</span></em><span class="sig-paren">)</span><a class="headerlink" href="#c.em_pd_nr_perf_states" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the number of performance states of a perf. domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_perf_domain</span> <span class="pre">*pd</span></code></dt><dd><p>performance domain for which this must be done</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>the number of performance states in the performance domain table</p>
<dl class="c function">
<dt id="c.em_pd_get">
<em class="property"><span class="pre">struct</span></em> <a class="reference internal" href="#c.em_perf_domain" title="em_perf_domain"><span class="pre">em_perf_domain</span></a> <span class="pre">*</span><code class="sig-name descname"><span class="pre">em_pd_get</span></code><span class="sig-paren">(</span><em class="property"><span class="pre">struct</span></em> <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="pre">device</span></a> <span class="pre">*</span><em><span class="pre">dev</span></em><span class="sig-paren">)</span><a class="headerlink" href="#c.em_pd_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the performance domain for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device to find the performance domain for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the performance domain to which <strong>dev</strong> belongs, or NULL if it doesn’t
exist.</p>
<dl class="c function">
<dt id="c.em_cpu_get">
<em class="property"><span class="pre">struct</span></em> <a class="reference internal" href="#c.em_perf_domain" title="em_perf_domain"><span class="pre">em_perf_domain</span></a> <span class="pre">*</span><code class="sig-name descname"><span class="pre">em_cpu_get</span></code><span class="sig-paren">(</span><span class="pre">int</span> <em><span class="pre">cpu</span></em><span class="sig-paren">)</span><a class="headerlink" href="#c.em_cpu_get" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the performance domain for a CPU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">cpu</span></code></dt><dd><p>CPU to find the performance domain for</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the performance domain to which <strong>cpu</strong> belongs, or NULL if it doesn’t
exist.</p>
<dl class="c function">
<dt id="c.em_dev_register_perf_domain">
<span class="pre">int</span> <code class="sig-name descname"><span class="pre">em_dev_register_perf_domain</span></code><span class="sig-paren">(</span><em class="property"><span class="pre">struct</span></em> <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="pre">device</span></a> <span class="pre">*</span><em><span class="pre">dev</span></em>, <span class="pre">unsigned</span> <span class="pre">int</span> <em><span class="pre">nr_states</span></em>, <em class="property"><span class="pre">struct</span></em> <span class="pre">em_data_callback</span> <span class="pre">*</span><em><span class="pre">cb</span></em>, <span class="pre">cpumask_t</span> <span class="pre">*</span><em><span class="pre">cpus</span></em>, <span class="pre">bool</span> <em><span class="pre">milliwatts</span></em><span class="sig-paren">)</span><a class="headerlink" href="#c.em_dev_register_perf_domain" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register the Energy Model (EM) for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device for which the EM is to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_states</span></code></dt><dd><p>Number of performance states to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">em_data_callback</span> <span class="pre">*cb</span></code></dt><dd><p>Callback functions providing the data of the Energy Model</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cpumask_t</span> <span class="pre">*cpus</span></code></dt><dd><p>Pointer to cpumask_t, which in case of a CPU device is
obligatory. It can be taken from i.e. ‘policy-&gt;cpus’. For other
type of devices this should be set to NULL.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">milliwatts</span></code></dt><dd><p>Flag indicating that the power values are in milliWatts or
in some other scale. It must be set properly.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create Energy Model tables for a performance domain using the callbacks
defined in cb.</p>
<p>The <strong>milliwatts</strong> is important to set with correct value. Some kernel
sub-systems might rely on this flag and check if all devices in the EM are
using the same scale.</p>
<p>If multiple clients register the same performance domain, all but the first
registration will be ignored.</p>
<p>Return 0 on success</p>
<dl class="c function">
<dt id="c.em_dev_unregister_perf_domain">
<span class="pre">void</span> <code class="sig-name descname"><span class="pre">em_dev_unregister_perf_domain</span></code><span class="sig-paren">(</span><em class="property"><span class="pre">struct</span></em> <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><span class="pre">device</span></a> <span class="pre">*</span><em><span class="pre">dev</span></em><span class="sig-paren">)</span><a class="headerlink" href="#c.em_dev_unregister_perf_domain" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unregister Energy Model (EM) for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>Device for which the EM is registered</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister the EM for the specified <strong>dev</strong> (but not a CPU device).</p>
</section>
</section>
<section id="example-driver">
<h2>3. Example driver<a class="headerlink" href="#example-driver" title="Permalink to this headline">¶</a></h2>
<p>This section provides a simple example of a CPUFreq driver registering a
performance domain in the Energy Model framework using the (fake) ‘foo’
protocol. The driver implements an est_power() function to be provided to the
EM framework:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-&gt; drivers/cpufreq/foo_cpufreq.c

01    static int est_power(unsigned long *mW, unsigned long *KHz,
02                    struct device *dev)
03    {
04            long freq, power;
05
06            /* Use the &#39;foo&#39; protocol to ceil the frequency */
07            freq = foo_get_freq_ceil(dev, *KHz);
08            if (freq &lt; 0);
09                    return freq;
10
11            /* Estimate the power cost for the dev at the relevant freq. */
12            power = foo_estimate_power(dev, freq);
13            if (power &lt; 0);
14                    return power;
15
16            /* Return the values to the EM framework */
17            *mW = power;
18            *KHz = freq;
19
20            return 0;
21    }
22
23    static int foo_cpufreq_init(struct cpufreq_policy *policy)
24    {
25            struct em_data_callback em_cb = EM_DATA_CB(est_power);
26            struct device *cpu_dev;
27            int nr_opp, ret;
28
29            cpu_dev = get_cpu_device(cpumask_first(policy-&gt;cpus));
30
31            /* Do the actual CPUFreq init work ... */
32            ret = do_foo_cpufreq_init(policy);
33            if (ret)
34                    return ret;
35
36            /* Find the number of OPPs for this policy */
37            nr_opp = foo_get_nr_opp(policy);
38
39            /* And register the new performance domain */
40            em_dev_register_perf_domain(cpu_dev, nr_opp, &amp;em_cb, policy-&gt;cpus,
41                                        true);
42
43            return 0;
44    }
</pre></div>
</div>
</section>
</section>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="freezing-of-tasks.html" class="btn btn-neutral float-right" title="Freezing of tasks" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="drivers-testing.html" class="btn btn-neutral float-left" title="Testing suspend and resume support in device drivers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright The kernel development community.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>