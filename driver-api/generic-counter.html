

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Generic Counter Interface &mdash; The Linux Kernel  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Memory Controller drivers" href="memory-devices/index.html" />
    <link rel="prev" title="Ordering I/O writes to memory-mapped addresses" href="io_ordering.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                5.16.0-rc1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">Kernel Build System</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">The Linux kernel firmware guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">Open Firmware and Devicetree</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">fault-injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Kernel Livepatching</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="driver-model/index.html">Driver Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="ioctl.html">ioctl based interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">CPU and Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="infiniband.html">InfiniBand and Remote DMA (RDMA) Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="reset.html">Reset controller API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci/index.html">The Linux PCI driver implementer’s API guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="cxl/index.html">Compute Express Link</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmb.html">IPMB Driver for a Satellite MC</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipmi.html">The Linux IPMI Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="interconnect.html">Generic System Interconnect Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mailbox.html">The Common Mailbox Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mei/index.html">Intel(R) Management Engine Interface (Intel(R) MEI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtd/index.html">Memory Technology Device (MTD)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mmc/index.html">MMC/SD/SDIO card support</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvdimm/index.html">Non-Volatile Memory Device (NVDIMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio/index.html">The Linux RapidIO Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pin-control.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="md/index.html">RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="media/index.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfc/index.html">Near Field Communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="thermal/index.html">Thermal</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="acpi/index.html">ACPI Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="auxiliary_bus.html">Auxiliary Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="backlight/lp855x-driver.html">Kernel driver lp855x</a></li>
<li class="toctree-l2"><a class="reference internal" href="connector.html">Kernel Connector</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">Console Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="eisa.html">EISA bus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="isa.html">ISA Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="isapnp.html">ISA Plug &amp; Play support by Jaroslav Kysela &lt;perex&#64;suse.cz&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Generic Counter Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#theory">Theory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#signal">SIGNAL</a></li>
<li class="toctree-l4"><a class="reference internal" href="#synapse">SYNAPSE</a></li>
<li class="toctree-l4"><a class="reference internal" href="#count">COUNT</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#paradigm">Paradigm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#driver-api">Driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#driver-implementation">Driver Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#subsystem-architecture">Subsystem Architecture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#counter-device-driver">Counter device driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#counter-core">Counter core</a></li>
<li class="toctree-l4"><a class="reference internal" href="#counter-sysfs">Counter sysfs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#counter-chrdev">Counter chrdev</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#sysfs-interface">Sysfs Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#counter-character-device">Counter Character Device</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#counter-events">Counter events</a></li>
<li class="toctree-l4"><a class="reference internal" href="#userspace">Userspace</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="memory-devices/index.html">Memory Controller drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="ntb.html">NTB Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvmem.html">NVMEM Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="parport-lowlevel.html">PARPORT interface documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="pps.html">PPS - Pulse Per Second</a></li>
<li class="toctree-l2"><a class="reference internal" href="ptp.html">PTP hardware clock infrastructure for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy/index.html">Generic PHY Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pwm.html">Pulse Width Modulation (PWM) interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="pldmfw/index.html">PLDM Firmware Flash Update Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pldmfw/index.html#overview-of-the-pldmfw-library">Overview of the <code class="docutils literal notranslate"><span class="pre">pldmfw</span></code> library</a></li>
<li class="toctree-l2"><a class="reference internal" href="rfkill.html">rfkill - RF kill switch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="serial/index.html">Support for Serial devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sm501.html">SM501 Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="surface_aggregator/index.html">Surface System Aggregator Module (SSAM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="switchtec.html">Linux Switchtec Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="sync_file.html">Sync File API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio.html">VFIO - “Virtual Function I/O” </a></li>
<li class="toctree-l2"><a class="reference internal" href="xilinx/index.html">Xilinx FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="xillybus.html">Xillybus driver for generic FPGA interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="zorro.html">Writing Device Drivers for Zorro Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">locking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../accounting/index.html">Accounting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cdrom/index.html">cdrom</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cpu-freq/index.html">Linux CPUFreq - CPU frequency and voltage scaling code in the Linux(TM) kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ide/index.html">Integrated Drive Electronics (IDE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fpga/index.html">fpga</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../i2c/index.html">I2C/SMBus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isdn/index.html">ISDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../infiniband/index.html">InfiniBand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../netlabel/index.html">NetLabel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pcmcia/index.html">pcmcia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../power/index.html">Power Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target/index.html">TCM Virtual Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../timers/index.html">timers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../spi/index.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w1/index.html">1-Wire Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watchdog/index.html">Linux Watchdog Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">Linux Virtualization Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hwmon/index.html">Linux Hardware Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Filesystems in the Linux kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usb/index.html">USB support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PCI/index.html">Linux PCI Bus Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scsi/index.html">Linux SCSI Subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scheduler/index.html">Linux Scheduler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mhi/index.html">MHI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm-annotations.html">Assembler Annotations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch.html">CPU Architectures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">Unsorted Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-types">Atomic Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#atomic-bitops">Atomic bitops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../watch_queue.html">General notification mechanism</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>Generic Counter Interface</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/driver-api/generic-counter.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="generic-counter-interface">
<h1>Generic Counter Interface<a class="headerlink" href="#generic-counter-interface" title="Permalink to this headline">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Counter devices are prevalent among a diverse spectrum of industries.
The ubiquitous presence of these devices necessitates a common interface
and standard of interaction and exposure. This driver API attempts to
resolve the issue of duplicate code found among existing counter device
drivers by introducing a generic counter interface for consumption. The
Generic Counter interface enables drivers to support and expose a common
set of components and functionality present in counter devices.</p>
</section>
<section id="theory">
<h2>Theory<a class="headerlink" href="#theory" title="Permalink to this headline">¶</a></h2>
<p>Counter devices can vary greatly in design, but regardless of whether
some devices are quadrature encoder counters or tally counters, all
counter devices consist of a core set of components. This core set of
components, shared by all counter devices, is what forms the essence of
the Generic Counter interface.</p>
<p>There are three core components to a counter:</p>
<ul class="simple">
<li><p>Signal:
Stream of data to be evaluated by the counter.</p></li>
<li><p>Synapse:
Association of a Signal, and evaluation trigger, with a Count.</p></li>
<li><p>Count:
Accumulation of the effects of connected Synapses.</p></li>
</ul>
<section id="signal">
<h3>SIGNAL<a class="headerlink" href="#signal" title="Permalink to this headline">¶</a></h3>
<p>A Signal represents a stream of data. This is the input data that is
evaluated by the counter to determine the count data; e.g. a quadrature
signal output line of a rotary encoder. Not all counter devices provide
user access to the Signal data, so exposure is optional for drivers.</p>
<p>When the Signal data is available for user access, the Generic Counter
interface provides the following available signal values:</p>
<ul class="simple">
<li><p>SIGNAL_LOW:
Signal line is in a low state.</p></li>
<li><p>SIGNAL_HIGH:
Signal line is in a high state.</p></li>
</ul>
<p>A Signal may be associated with one or more Counts.</p>
</section>
<section id="synapse">
<h3>SYNAPSE<a class="headerlink" href="#synapse" title="Permalink to this headline">¶</a></h3>
<p>A Synapse represents the association of a Signal with a Count. Signal
data affects respective Count data, and the Synapse represents this
relationship.</p>
<p>The Synapse action mode specifies the Signal data condition that
triggers the respective Count’s count function evaluation to update the
count data. The Generic Counter interface provides the following
available action modes:</p>
<ul class="simple">
<li><p>None:
Signal does not trigger the count function. In Pulse-Direction count
function mode, this Signal is evaluated as Direction.</p></li>
<li><p>Rising Edge:
Low state transitions to high state.</p></li>
<li><p>Falling Edge:
High state transitions to low state.</p></li>
<li><p>Both Edges:
Any state transition.</p></li>
</ul>
<p>A counter is defined as a set of input signals associated with count
data that are generated by the evaluation of the state of the associated
input signals as defined by the respective count functions. Within the
context of the Generic Counter interface, a counter consists of Counts
each associated with a set of Signals, whose respective Synapse
instances represent the count function update conditions for the
associated Counts.</p>
<p>A Synapse associates one Signal with one Count.</p>
</section>
<section id="count">
<h3>COUNT<a class="headerlink" href="#count" title="Permalink to this headline">¶</a></h3>
<p>A Count represents the accumulation of the effects of connected
Synapses; i.e. the count data for a set of Signals. The Generic
Counter interface represents the count data as a natural number.</p>
<p>A Count has a count function mode which represents the update behavior
for the count data. The Generic Counter interface provides the following
available count function modes:</p>
<ul class="simple">
<li><p>Increase:
Accumulated count is incremented.</p></li>
<li><p>Decrease:
Accumulated count is decremented.</p></li>
<li><p>Pulse-Direction:
Rising edges on signal A updates the respective count. The input level
of signal B determines direction.</p></li>
<li><p>Quadrature:
A pair of quadrature encoding signals are evaluated to determine
position and direction. The following Quadrature modes are available:</p>
<ul>
<li><p>x1 A:
If direction is forward, rising edges on quadrature pair signal A
updates the respective count; if the direction is backward, falling
edges on quadrature pair signal A updates the respective count.
Quadrature encoding determines the direction.</p></li>
<li><p>x1 B:
If direction is forward, rising edges on quadrature pair signal B
updates the respective count; if the direction is backward, falling
edges on quadrature pair signal B updates the respective count.
Quadrature encoding determines the direction.</p></li>
<li><p>x2 A:
Any state transition on quadrature pair signal A updates the
respective count. Quadrature encoding determines the direction.</p></li>
<li><p>x2 B:
Any state transition on quadrature pair signal B updates the
respective count. Quadrature encoding determines the direction.</p></li>
<li><p>x4:
Any state transition on either quadrature pair signals updates the
respective count. Quadrature encoding determines the direction.</p></li>
</ul>
</li>
</ul>
<p>A Count has a set of one or more associated Synapses.</p>
</section>
</section>
<section id="paradigm">
<h2>Paradigm<a class="headerlink" href="#paradigm" title="Permalink to this headline">¶</a></h2>
<p>The most basic counter device may be expressed as a single Count
associated with a single Signal via a single Synapse. Take for example
a counter device which simply accumulates a count of rising edges on a
source input line:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        Count                Synapse        Signal
        -----                -------        ------
+---------------------+
| Data: Count         |    Rising Edge     ________
| Function: Increase  |  &lt;-------------   / Source \
|                     |                  ____________
+---------------------+
</pre></div>
</div>
<p>In this example, the Signal is a source input line with a pulsing
voltage, while the Count is a persistent count value which is repeatedly
incremented. The Signal is associated with the respective Count via a
Synapse. The increase function is triggered by the Signal data condition
specified by the Synapse – in this case a rising edge condition on the
voltage input line. In summary, the counter device existence and
behavior is aptly represented by respective Count, Signal, and Synapse
components: a rising edge condition triggers an increase function on an
accumulating count datum.</p>
<p>A counter device is not limited to a single Signal; in fact, in theory
many Signals may be associated with even a single Count. For example, a
quadrature encoder counter device can keep track of position based on
the states of two input lines:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>           Count                 Synapse     Signal
           -----                 -------     ------
+-------------------------+
| Data: Position          |    Both Edges     ___
| Function: Quadrature x4 |  &lt;------------   / A \
|                         |                 _______
|                         |
|                         |    Both Edges     ___
|                         |  &lt;------------   / B \
|                         |                 _______
+-------------------------+
</pre></div>
</div>
<p>In this example, two Signals (quadrature encoder lines A and B) are
associated with a single Count: a rising or falling edge on either A or
B triggers the “Quadrature x4” function which determines the direction
of movement and updates the respective position data. The “Quadrature
x4” function is likely implemented in the hardware of the quadrature
encoder counter device; the Count, Signals, and Synapses simply
represent this hardware behavior and functionality.</p>
<p>Signals associated with the same Count can have differing Synapse action
mode conditions. For example, a quadrature encoder counter device
operating in a non-quadrature Pulse-Direction mode could have one input
line dedicated for movement and a second input line dedicated for
direction:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>           Count                   Synapse      Signal
           -----                   -------      ------
+---------------------------+
| Data: Position            |    Rising Edge     ___
| Function: Pulse-Direction |  &lt;-------------   / A \ (Movement)
|                           |                  _______
|                           |
|                           |       None         ___
|                           |  &lt;-------------   / B \ (Direction)
|                           |                  _______
+---------------------------+
</pre></div>
</div>
<p>Only Signal A triggers the “Pulse-Direction” update function, but the
instantaneous state of Signal B is still required in order to know the
direction so that the position data may be properly updated. Ultimately,
both Signals are associated with the same Count via two respective
Synapses, but only one Synapse has an active action mode condition which
triggers the respective count function while the other is left with a
“None” condition action mode to indicate its respective Signal’s
availability for state evaluation despite its non-triggering mode.</p>
<p>Keep in mind that the Signal, Synapse, and Count are abstract
representations which do not need to be closely married to their
respective physical sources. This allows the user of a counter to
divorce themselves from the nuances of physical components (such as
whether an input line is differential or single-ended) and instead focus
on the core idea of what the data and process represent (e.g. position
as interpreted from quadrature encoding data).</p>
</section>
<section id="driver-api">
<h2>Driver API<a class="headerlink" href="#driver-api" title="Permalink to this headline">¶</a></h2>
<p>Driver authors may utilize the Generic Counter interface in their code
by including the include/linux/counter.h header file. This header file
provides several core data structures, function prototypes, and macros
for defining a counter device.</p>
<dl class="c struct">
<dt id="c.counter_comp">
<em class="property"><span class="pre">struct</span> </em><code class="sig-name descname"><span class="pre">counter_comp</span></code><a class="headerlink" href="#c.counter_comp" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Counter component node</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_comp {
  enum counter_comp_type type;
  const char *name;
  void *priv;
  union {
    int (*action_read)(struct counter_device *counter,struct counter_count *count,struct counter_synapse *synapse, enum counter_synapse_action *action);
    int (*device_u8_read)(struct counter_device *counter, u8 *val);
    int (*count_u8_read)(struct counter_device *counter, struct counter_count *count, u8 *val);
    int (*signal_u8_read)(struct counter_device *counter, struct counter_signal *signal, u8 *val);
    int (*device_u32_read)(struct counter_device *counter, u32 *val);
    int (*count_u32_read)(struct counter_device *counter, struct counter_count *count, u32 *val);
    int (*signal_u32_read)(struct counter_device *counter, struct counter_signal *signal, u32 *val);
    int (*device_u64_read)(struct counter_device *counter, u64 *val);
    int (*count_u64_read)(struct counter_device *counter, struct counter_count *count, u64 *val);
    int (*signal_u64_read)(struct counter_device *counter, struct counter_signal *signal, u64 *val);
  };
  union {
    int (*action_write)(struct counter_device *counter,struct counter_count *count,struct counter_synapse *synapse, enum counter_synapse_action action);
    int (*device_u8_write)(struct counter_device *counter, u8 val);
    int (*count_u8_write)(struct counter_device *counter, struct counter_count *count, u8 val);
    int (*signal_u8_write)(struct counter_device *counter, struct counter_signal *signal, u8 val);
    int (*device_u32_write)(struct counter_device *counter, u32 val);
    int (*count_u32_write)(struct counter_device *counter, struct counter_count *count, u32 val);
    int (*signal_u32_write)(struct counter_device *counter, struct counter_signal *signal, u32 val);
    int (*device_u64_write)(struct counter_device *counter, u64 val);
    int (*count_u64_write)(struct counter_device *counter, struct counter_count *count, u64 val);
    int (*signal_u64_write)(struct counter_device *counter, struct counter_signal *signal, u64 val);
  };
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">type</span></code></dt><dd><p>Counter component data type</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>device-specific component name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>component-relevant data
<strong>action_read</strong>         Synapse action mode read callback. The read value of the</p>
<blockquote>
<div><p>respective Synapse action mode should be passed back via
the action parameter.</p>
</div></blockquote>
<dl class="simple">
<dt><strong>device_u8_read</strong>      Device u8 component read callback. The read value of the</dt><dd><p>respective Device u8 component should be passed back via
the val parameter.</p>
</dd>
<dt><strong>count_u8_read</strong>       Count u8 component read callback. The read value of the</dt><dd><p>respective Count u8 component should be passed back via
the val parameter.</p>
</dd>
<dt><strong>signal_u8_read</strong>      Signal u8 component read callback. The read value of the</dt><dd><p>respective Signal u8 component should be passed back via
the val parameter.</p>
</dd>
<dt><strong>device_u32_read</strong>     Device u32 component read callback. The read value of</dt><dd><p>the respective Device u32 component should be passed
back via the val parameter.</p>
</dd>
<dt><strong>count_u32_read</strong>      Count u32 component read callback. The read value of the</dt><dd><p>respective Count u32 component should be passed back via
the val parameter.</p>
</dd>
<dt><strong>signal_u32_read</strong>     Signal u32 component read callback. The read value of</dt><dd><p>the respective Signal u32 component should be passed
back via the val parameter.</p>
</dd>
<dt><strong>device_u64_read</strong>     Device u64 component read callback. The read value of</dt><dd><p>the respective Device u64 component should be passed
back via the val parameter.</p>
</dd>
<dt><strong>count_u64_read</strong>      Count u64 component read callback. The read value of the</dt><dd><p>respective Count u64 component should be passed back via
the val parameter.</p>
</dd>
<dt><strong>signal_u64_read</strong>     Signal u64 component read callback. The read value of</dt><dd><p>the respective Signal u64 component should be passed
back via the val parameter.</p>
</dd>
<dt><strong>action_write</strong>        Synapse action mode write callback. The write value of</dt><dd><p>the respective Synapse action mode is passed via the
action parameter.</p>
</dd>
<dt><strong>device_u8_write</strong>     Device u8 component write callback. The write value of</dt><dd><p>the respective Device u8 component is passed via the val
parameter.</p>
</dd>
<dt><strong>count_u8_write</strong>      Count u8 component write callback. The write value of</dt><dd><p>the respective Count u8 component is passed via the val
parameter.</p>
</dd>
<dt><strong>signal_u8_write</strong>     Signal u8 component write callback. The write value of</dt><dd><p>the respective Signal u8 component is passed via the val
parameter.</p>
</dd>
<dt><strong>device_u32_write</strong>    Device u32 component write callback. The write value of</dt><dd><p>the respective Device u32 component is passed via the
val parameter.</p>
</dd>
<dt><strong>count_u32_write</strong>     Count u32 component write callback. The write value of</dt><dd><p>the respective Count u32 component is passed via the val
parameter.</p>
</dd>
<dt><strong>signal_u32_write</strong>    Signal u32 component write callback. The write value of</dt><dd><p>the respective Signal u32 component is passed via the
val parameter.</p>
</dd>
<dt><strong>device_u64_write</strong>    Device u64 component write callback. The write value of</dt><dd><p>the respective Device u64 component is passed via the
val parameter.</p>
</dd>
<dt><strong>count_u64_write</strong>     Count u64 component write callback. The write value of</dt><dd><p>the respective Count u64 component is passed via the val
parameter.</p>
</dd>
<dt><strong>signal_u64_write</strong>    Signal u64 component write callback. The write value of</dt><dd><p>the respective Signal u64 component is passed via the
val parameter.</p>
</dd>
</dl>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{unnamed_union}</span></code></dt><dd><p>anonymous</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.counter_signal">
<em class="property"><span class="pre">struct</span> </em><code class="sig-name descname"><span class="pre">counter_signal</span></code><a class="headerlink" href="#c.counter_signal" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Counter Signal node</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_signal {
  int id;
  const char *name;
  struct counter_comp *ext;
  size_t num_ext;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>unique ID used to identify the Signal</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>device-specific Signal name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ext</span></code></dt><dd><p>optional array of Signal extensions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_ext</span></code></dt><dd><p>number of Signal extensions specified in <strong>ext</strong></p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.counter_synapse">
<em class="property"><span class="pre">struct</span> </em><code class="sig-name descname"><span class="pre">counter_synapse</span></code><a class="headerlink" href="#c.counter_synapse" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Counter Synapse node</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_synapse {
  const enum counter_synapse_action *actions_list;
  size_t num_actions;
  struct counter_signal *signal;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">actions_list</span></code></dt><dd><p>array of available action modes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_actions</span></code></dt><dd><p>number of action modes specified in <strong>actions_list</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signal</span></code></dt><dd><p>pointer to the associated Signal</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.counter_count">
<em class="property"><span class="pre">struct</span> </em><code class="sig-name descname"><span class="pre">counter_count</span></code><a class="headerlink" href="#c.counter_count" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Counter Count node</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_count {
  int id;
  const char *name;
  const enum counter_function *functions_list;
  size_t num_functions;
  struct counter_synapse *synapses;
  size_t num_synapses;
  struct counter_comp *ext;
  size_t num_ext;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code></dt><dd><p>unique ID used to identify the Count</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>device-specific Count name</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">functions_list</span></code></dt><dd><p>array of available function modes</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_functions</span></code></dt><dd><p>number of function modes specified in <strong>functions_list</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">synapses</span></code></dt><dd><p>array of Synapses for initialization</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_synapses</span></code></dt><dd><p>number of Synapses specified in <strong>synapses</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ext</span></code></dt><dd><p>optional array of Count extensions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_ext</span></code></dt><dd><p>number of Count extensions specified in <strong>ext</strong></p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.counter_event_node">
<em class="property"><span class="pre">struct</span> </em><code class="sig-name descname"><span class="pre">counter_event_node</span></code><a class="headerlink" href="#c.counter_event_node" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Counter Event node</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_event_node {
  struct list_head l;
  u8 event;
  u8 channel;
  struct list_head comp_list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">l</span></code></dt><dd><p>list of current watching Counter events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">event</span></code></dt><dd><p>event that triggers</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">channel</span></code></dt><dd><p>event channel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">comp_list</span></code></dt><dd><p>list of components to watch when event triggers</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.counter_ops">
<em class="property"><span class="pre">struct</span> </em><code class="sig-name descname"><span class="pre">counter_ops</span></code><a class="headerlink" href="#c.counter_ops" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Callbacks from driver</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_ops {
  int (*signal_read)(struct counter_device *counter,struct counter_signal *signal, enum counter_signal_level *level);
  int (*count_read)(struct counter_device *counter, struct counter_count *count, u64 *value);
  int (*count_write)(struct counter_device *counter, struct counter_count *count, u64 value);
  int (*function_read)(struct counter_device *counter,struct counter_count *count, enum counter_function *function);
  int (*function_write)(struct counter_device *counter,struct counter_count *count, enum counter_function function);
  int (*action_read)(struct counter_device *counter,struct counter_count *count,struct counter_synapse *synapse, enum counter_synapse_action *action);
  int (*action_write)(struct counter_device *counter,struct counter_count *count,struct counter_synapse *synapse, enum counter_synapse_action action);
  int (*events_configure)(struct counter_device *counter);
  int (*watch_validate)(struct counter_device *counter, const struct counter_watch *watch);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">signal_read</span></code></dt><dd><p>optional read callback for Signals. The read level of
the respective Signal should be passed back via the
level parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_read</span></code></dt><dd><p>read callback for Counts. The read value of the
respective Count should be passed back via the value
parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">count_write</span></code></dt><dd><p>optional write callback for Counts. The write value for
the respective Count is passed in via the value
parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">function_read</span></code></dt><dd><p>read callback the Count function modes. The read
function mode of the respective Count should be passed
back via the function parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">function_write</span></code></dt><dd><p>optional write callback for Count function modes. The
function mode to write for the respective Count is
passed in via the function parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">action_read</span></code></dt><dd><p>optional read callback the Synapse action modes. The
read action mode of the respective Synapse should be
passed back via the action parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">action_write</span></code></dt><dd><p>optional write callback for Synapse action modes. The
action mode to write for the respective Synapse is
passed in via the action parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">events_configure</span></code></dt><dd><p>optional write callback to configure events. The list of
<a class="reference internal" href="#c.counter_event_node" title="counter_event_node"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_event_node</span></code></a> may be accessed via the
events_list member of the counter parameter.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">watch_validate</span></code></dt><dd><p>optional callback to validate a watch. The Counter
component watch configuration is passed in via the watch
parameter. A return value of 0 indicates a valid Counter
component watch configuration.</p>
</dd>
</dl>
<dl class="c struct">
<dt id="c.counter_device">
<em class="property"><span class="pre">struct</span> </em><code class="sig-name descname"><span class="pre">counter_device</span></code><a class="headerlink" href="#c.counter_device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Counter data structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_device {
  const char *name;
  struct device *parent;
  const struct counter_ops *ops;
  struct counter_signal *signals;
  size_t num_signals;
  struct counter_count *counts;
  size_t num_counts;
  struct counter_comp *ext;
  size_t num_ext;
  void *priv;
  struct device dev;
  struct cdev chrdev;
  struct list_head events_list;
  spinlock_t events_list_lock;
  struct list_head next_events_list;
  struct mutex n_events_list_lock;
  struct counter_event *events;
  wait_queue_head_t events_wait;
  spinlock_t events_in_lock;
  struct mutex events_out_lock;
  struct mutex ops_exist_lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>name of the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>optional parent device providing the counters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>callbacks from driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">signals</span></code></dt><dd><p>array of Signals</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_signals</span></code></dt><dd><p>number of Signals specified in <strong>signals</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">counts</span></code></dt><dd><p>array of Counts</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_counts</span></code></dt><dd><p>number of Counts specified in <strong>counts</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ext</span></code></dt><dd><p>optional array of Counter device extensions</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">num_ext</span></code></dt><dd><p>number of Counter device extensions specified in <strong>ext</strong></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">priv</span></code></dt><dd><p>optional private data supplied by driver</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>internal device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">chrdev</span></code></dt><dd><p>internal character device structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">events_list</span></code></dt><dd><p>list of current watching Counter events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">events_list_lock</span></code></dt><dd><p>lock to protect Counter events list operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">next_events_list</span></code></dt><dd><p>list of next watching Counter events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n_events_list_lock</span></code></dt><dd><p>lock to protect Counter next events list operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">events</span></code></dt><dd><p>queue of detected Counter events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">events_wait</span></code></dt><dd><p>wait queue to allow blocking reads of Counter events</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">events_in_lock</span></code></dt><dd><p>lock to protect Counter events queue in operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">events_out_lock</span></code></dt><dd><p>lock to protect Counter events queue out operations</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops_exist_lock</span></code></dt><dd><p>lock to prevent use during removal</p>
</dd>
</dl>
<dl class="c function">
<dt id="c.counter_register">
<span class="pre">int</span> <code class="sig-name descname"><span class="pre">counter_register</span></code><span class="sig-paren">(</span><em class="property"><span class="pre">struct</span></em> <a class="reference internal" href="#c.counter_device" title="counter_device"><span class="pre">counter_device</span></a> <span class="pre">*</span><em class="property"><span class="pre">const</span></em> <em><span class="pre">counter</span></em><span class="sig-paren">)</span><a class="headerlink" href="#c.counter_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>register Counter to the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_device</span> <span class="pre">*const</span> <span class="pre">counter</span></code></dt><dd><p>pointer to Counter to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function registers a Counter to the system. A sysfs “counter” directory
will be created and populated with sysfs attributes correlating with the
Counter Signals, Synapses, and Counts respectively.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error number on failure.</p>
<dl class="c function">
<dt id="c.counter_unregister">
<span class="pre">void</span> <code class="sig-name descname"><span class="pre">counter_unregister</span></code><span class="sig-paren">(</span><em class="property"><span class="pre">struct</span></em> <a class="reference internal" href="#c.counter_device" title="counter_device"><span class="pre">counter_device</span></a> <span class="pre">*</span><em class="property"><span class="pre">const</span></em> <em><span class="pre">counter</span></em><span class="sig-paren">)</span><a class="headerlink" href="#c.counter_unregister" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>unregister Counter from the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_device</span> <span class="pre">*const</span> <span class="pre">counter</span></code></dt><dd><p>pointer to Counter to unregister</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The Counter is unregistered from the system.</p>
<dl class="c function">
<dt id="c.devm_counter_register">
<span class="pre">int</span> <code class="sig-name descname"><span class="pre">devm_counter_register</span></code><span class="sig-paren">(</span><em class="property"><span class="pre">struct</span></em> <a class="reference internal" href="infrastructure.html#c.device" title="device"><span class="pre">device</span></a> <span class="pre">*</span><em><span class="pre">dev</span></em>, <em class="property"><span class="pre">struct</span></em> <a class="reference internal" href="#c.counter_device" title="counter_device"><span class="pre">counter_device</span></a> <span class="pre">*</span><em class="property"><span class="pre">const</span></em> <em><span class="pre">counter</span></em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_counter_register" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resource-managed counter_register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*dev</span></code></dt><dd><p>device to allocate counter_device for</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_device</span> <span class="pre">*const</span> <span class="pre">counter</span></code></dt><dd><p>pointer to Counter to register</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed counter_register. The Counter registered with this function is
automatically unregistered on driver detach. This function calls
counter_register internally. Refer to that function for more information.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error number on failure.</p>
<dl class="c function">
<dt id="c.counter_push_event">
<span class="pre">void</span> <code class="sig-name descname"><span class="pre">counter_push_event</span></code><span class="sig-paren">(</span><em class="property"><span class="pre">struct</span></em> <a class="reference internal" href="#c.counter_device" title="counter_device"><span class="pre">counter_device</span></a> <span class="pre">*</span><em class="property"><span class="pre">const</span></em> <em><span class="pre">counter</span></em>, <em class="property"><span class="pre">const</span></em> <span class="pre">u8</span> <em><span class="pre">event</span></em>, <em class="property"><span class="pre">const</span></em> <span class="pre">u8</span> <em><span class="pre">channel</span></em><span class="sig-paren">)</span><a class="headerlink" href="#c.counter_push_event" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>queue event for userspace reading</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_device</span> <span class="pre">*const</span> <span class="pre">counter</span></code></dt><dd><p>pointer to Counter structure</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">event</span></code></dt><dd><p>triggered event</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">channel</span></code></dt><dd><p>event channel</p>
</dd>
</dl>
<p><strong>Note</strong></p>
<p>If no one is watching for the respective event, it is silently
discarded.</p>
</section>
<section id="driver-implementation">
<h2>Driver Implementation<a class="headerlink" href="#driver-implementation" title="Permalink to this headline">¶</a></h2>
<p>To support a counter device, a driver must first allocate the available
Counter Signals via counter_signal structures. These Signals should
be stored as an array and set to the signals array member of an
allocated counter_device structure before the Counter is registered to
the system.</p>
<p>Counter Counts may be allocated via counter_count structures, and
respective Counter Signal associations (Synapses) made via
counter_synapse structures. Associated counter_synapse structures are
stored as an array and set to the synapses array member of the
respective counter_count structure. These counter_count structures are
set to the counts array member of an allocated counter_device structure
before the Counter is registered to the system.</p>
<p>Driver callbacks must be provided to the counter_device structure in
order to communicate with the device: to read and write various Signals
and Counts, and to set and get the “action mode” and “function mode” for
various Synapses and Counts respectively.</p>
<p>A defined counter_device structure may be registered to the system by
passing it to the counter_register function, and unregistered by passing
it to the counter_unregister function. Similarly, the
devm_counter_register function may be used if device memory-managed
registration is desired.</p>
<p>The <a class="reference internal" href="#c.counter_comp" title="counter_comp"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_comp</span></code></a> structure is used to define counter extensions
for Signals, Synapses, and Counts.</p>
<p>The “type” member specifies the type of high-level data (e.g. BOOL,
COUNT_DIRECTION, etc.) handled by this extension. The “<code class="docutils literal notranslate"><span class="pre">*_read</span></code>” and
“<code class="docutils literal notranslate"><span class="pre">*_write</span></code>” members can then be set by the counter device driver with
callbacks to handle that data using native C data types (i.e. u8, u64,
etc.).</p>
<p>Convenience macros such as <code class="docutils literal notranslate"><span class="pre">COUNTER_COMP_COUNT_U64</span></code> are provided for
use by driver authors. In particular, driver authors are expected to use
the provided macros for standard Counter subsystem attributes in order
to maintain a consistent interface for userspace. For example, a counter
device driver may define several standard attributes like so:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct counter_comp count_ext[] = {
        COUNTER_COMP_DIRECTION(count_direction_read),
        COUNTER_COMP_ENABLE(count_enable_read, count_enable_write),
        COUNTER_COMP_CEILING(count_ceiling_read, count_ceiling_write),
};
</pre></div>
</div>
<p>This makes it simple to see, add, and modify the attributes that are
supported by this driver (“direction”, “enable”, and “ceiling”) and to
maintain this code without getting lost in a web of struct braces.</p>
<p>Callbacks must match the function type expected for the respective
component or extension. These function types are defined in the <a class="reference internal" href="#c.counter_comp" title="counter_comp"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">counter_comp</span></code></a> structure as the “<code class="docutils literal notranslate"><span class="pre">*_read</span></code>” and “<code class="docutils literal notranslate"><span class="pre">*_write</span></code>” union
members.</p>
<p>The corresponding callback prototypes for the extensions mentioned in
the previous example above would be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int count_direction_read(struct counter_device *counter,
                         struct counter_count *count,
                         enum counter_count_direction *direction);
int count_enable_read(struct counter_device *counter,
                      struct counter_count *count, u8 *enable);
int count_enable_write(struct counter_device *counter,
                       struct counter_count *count, u8 enable);
int count_ceiling_read(struct counter_device *counter,
                       struct counter_count *count, u64 *ceiling);
int count_ceiling_write(struct counter_device *counter,
                        struct counter_count *count, u64 ceiling);
</pre></div>
</div>
<p>Determining the type of extension to create is a matter of scope.</p>
<ul>
<li><p>Signal extensions are attributes that expose information/control
specific to a Signal. These types of attributes will exist under a
Signal’s directory in sysfs.</p>
<p>For example, if you have an invert feature for a Signal, you can have
a Signal extension called “invert” that toggles that feature:
/sys/bus/counter/devices/counterX/signalY/invert</p>
</li>
<li><p>Count extensions are attributes that expose information/control
specific to a Count. These type of attributes will exist under a
Count’s directory in sysfs.</p>
<p>For example, if you want to pause/unpause a Count from updating, you
can have a Count extension called “enable” that toggles such:
/sys/bus/counter/devices/counterX/countY/enable</p>
</li>
<li><p>Device extensions are attributes that expose information/control
non-specific to a particular Count or Signal. This is where you would
put your global features or other miscellaneous functionality.</p>
<p>For example, if your device has an overtemp sensor, you can report the
chip overheated via a device extension called “error_overtemp”:
/sys/bus/counter/devices/counterX/error_overtemp</p>
</li>
</ul>
</section>
<section id="subsystem-architecture">
<h2>Subsystem Architecture<a class="headerlink" href="#subsystem-architecture" title="Permalink to this headline">¶</a></h2>
<p>Counter drivers pass and take data natively (i.e. <code class="docutils literal notranslate"><span class="pre">u8</span></code>, <code class="docutils literal notranslate"><span class="pre">u64</span></code>, etc.)
and the shared counter module handles the translation between the sysfs
interface. This guarantees a standard userspace interface for all
counter drivers, and enables a Generic Counter chrdev interface via a
generalized device driver ABI.</p>
<p>A high-level view of how a count value is passed down from a counter
driver is exemplified by the following. The driver callbacks are first
registered to the Counter core component for use by the Counter
userspace interface components:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Driver callbacks registration:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                +----------------------------+
                | Counter device driver      |
                +----------------------------+
                | Processes data from device |
                +----------------------------+
                        |
                 -------------------
                / driver callbacks /
                -------------------
                        |
                        V
                +----------------------+
                | Counter core         |
                +----------------------+
                | Routes device driver |
                | callbacks to the     |
                | userspace interfaces |
                +----------------------+
                        |
                 -------------------
                / driver callbacks /
                -------------------
                        |
        +---------------+---------------+
        |                               |
        V                               V
+--------------------+          +---------------------+
| Counter sysfs      |          | Counter chrdev      |
+--------------------+          +---------------------+
| Translates to the  |          | Translates to the   |
| standard Counter   |          | standard Counter    |
| sysfs output       |          | character device    |
+--------------------+          +---------------------+
</pre></div>
</div>
<p>Thereafter, data can be transferred directly between the Counter device
driver and Counter userspace interface:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Count data request:
~~~~~~~~~~~~~~~~~~~
                 ----------------------
                / Counter device       \
                +----------------------+
                | Count register: 0x28 |
                +----------------------+
                        |
                 -----------------
                / raw count data /
                -----------------
                        |
                        V
                +----------------------------+
                | Counter device driver      |
                +----------------------------+
                | Processes data from device |
                |----------------------------|
                | Type: u64                  |
                | Value: 42                  |
                +----------------------------+
                        |
                 ----------
                / u64     /
                ----------
                        |
        +---------------+---------------+
        |                               |
        V                               V
+--------------------+          +---------------------+
| Counter sysfs      |          | Counter chrdev      |
+--------------------+          +---------------------+
| Translates to the  |          | Translates to the   |
| standard Counter   |          | standard Counter    |
| sysfs output       |          | character device    |
|--------------------|          |---------------------|
| Type: const char * |          | Type: u64           |
| Value: &quot;42&quot;        |          | Value: 42           |
+--------------------+          +---------------------+
        |                               |
 ---------------                 -----------------------
/ const char * /                / struct counter_event /
---------------                 -----------------------
        |                               |
        |                               V
        |                       +-----------+
        |                       | read      |
        |                       +-----------+
        |                       \ Count: 42 /
        |                        -----------
        |
        V
+--------------------------------------------------+
| `/sys/bus/counter/devices/counterX/countY/count` |
+--------------------------------------------------+
\ Count: &quot;42&quot;                                      /
 --------------------------------------------------
</pre></div>
</div>
<p>There are four primary components involved:</p>
<section id="counter-device-driver">
<h3>Counter device driver<a class="headerlink" href="#counter-device-driver" title="Permalink to this headline">¶</a></h3>
<p>Communicates with the hardware device to read/write data; e.g. counter
drivers for quadrature encoders, timers, etc.</p>
</section>
<section id="counter-core">
<h3>Counter core<a class="headerlink" href="#counter-core" title="Permalink to this headline">¶</a></h3>
<p>Registers the counter device driver to the system so that the respective
callbacks are called during userspace interaction.</p>
</section>
<section id="counter-sysfs">
<h3>Counter sysfs<a class="headerlink" href="#counter-sysfs" title="Permalink to this headline">¶</a></h3>
<p>Translates counter data to the standard Counter sysfs interface format
and vice versa.</p>
<p>Please refer to the <code class="docutils literal notranslate"><span class="pre">Documentation/ABI/testing/sysfs-bus-counter</span></code> file
for a detailed breakdown of the available Generic Counter interface
sysfs attributes.</p>
</section>
<section id="counter-chrdev">
<h3>Counter chrdev<a class="headerlink" href="#counter-chrdev" title="Permalink to this headline">¶</a></h3>
<p>Translates Counter events to the standard Counter character device; data
is transferred via standard character device read calls, while Counter
events are configured via ioctl calls.</p>
</section>
</section>
<section id="sysfs-interface">
<h2>Sysfs Interface<a class="headerlink" href="#sysfs-interface" title="Permalink to this headline">¶</a></h2>
<p>Several sysfs attributes are generated by the Generic Counter interface,
and reside under the <code class="docutils literal notranslate"><span class="pre">/sys/bus/counter/devices/counterX</span></code> directory,
where <code class="docutils literal notranslate"><span class="pre">X</span></code> is to the respective counter device id. Please see
<code class="docutils literal notranslate"><span class="pre">Documentation/ABI/testing/sysfs-bus-counter</span></code> for detailed information
on each Generic Counter interface sysfs attribute.</p>
<p>Through these sysfs attributes, programs and scripts may interact with
the Generic Counter paradigm Counts, Signals, and Synapses of respective
counter devices.</p>
</section>
<section id="counter-character-device">
<h2>Counter Character Device<a class="headerlink" href="#counter-character-device" title="Permalink to this headline">¶</a></h2>
<p>Counter character device nodes are created under the <code class="docutils literal notranslate"><span class="pre">/dev</span></code> directory
as <code class="docutils literal notranslate"><span class="pre">counterX</span></code>, where <code class="docutils literal notranslate"><span class="pre">X</span></code> is the respective counter device id.
Defines for the standard Counter data types are exposed via the
userspace <code class="docutils literal notranslate"><span class="pre">include/uapi/linux/counter.h</span></code> file.</p>
<section id="counter-events">
<h3>Counter events<a class="headerlink" href="#counter-events" title="Permalink to this headline">¶</a></h3>
<p>Counter device drivers can support Counter events by utilizing the
<code class="docutils literal notranslate"><span class="pre">counter_push_event</span></code> function:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void counter_push_event(struct counter_device *const counter, const u8 event,
                        const u8 channel);
</pre></div>
</div>
<p>The event id is specified by the <code class="docutils literal notranslate"><span class="pre">event</span></code> parameter; the event channel
id is specified by the <code class="docutils literal notranslate"><span class="pre">channel</span></code> parameter. When this function is
called, the Counter data associated with the respective event is
gathered, and a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_event</span></code> is generated for each datum and
pushed to userspace.</p>
<p>Counter events can be configured by users to report various Counter
data of interest. This can be conceptualized as a list of Counter
component read calls to perform. For example:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>COUNTER_EVENT_OVERFLOW</p></th>
<th class="head"><p>COUNTER_EVENT_INDEX</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Channel 0</p></td>
<td><p>Channel 0</p></td>
</tr>
<tr class="row-odd"><td rowspan="3"><ul class="simple">
<li><p>Count 0</p></li>
<li><p>Count 1</p></li>
<li><p>Signal 3</p></li>
<li><p>Count 4 Extension 2</p></li>
<li><p>Signal 5 Extension 0</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p>Signal 0</p></li>
<li><p>Signal 0 Extension 0</p></li>
<li><p>Extension 4</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>Channel 1</p></td>
</tr>
<tr class="row-odd"><td><ul class="simple">
<li><p>Signal 4</p></li>
<li><p>Signal 4 Extension 0</p></li>
<li><p>Count 7</p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>When <code class="docutils literal notranslate"><span class="pre">counter_push_event(counter,</span> <span class="pre">COUNTER_EVENT_INDEX,</span> <span class="pre">1)</span></code> is called
for example, it will go down the list for the <code class="docutils literal notranslate"><span class="pre">COUNTER_EVENT_INDEX</span></code>
event channel 1 and execute the read callbacks for Signal 4, Signal 4
Extension 0, and Count 7 – the data returned for each is pushed to a
kfifo as a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_event</span></code>, which userspace can retrieve via a
standard read operation on the respective character device node.</p>
</section>
<section id="userspace">
<h3>Userspace<a class="headerlink" href="#userspace" title="Permalink to this headline">¶</a></h3>
<p>Userspace applications can configure Counter events via ioctl operations
on the Counter character device node. There following ioctl codes are
supported and provided by the <code class="docutils literal notranslate"><span class="pre">linux/counter.h</span></code> userspace header file:</p>
<ul class="simple">
<li><p><code class="xref c c-macro docutils literal notranslate"><span class="pre">COUNTER_ADD_WATCH_IOCTL</span></code></p></li>
<li><p><code class="xref c c-macro docutils literal notranslate"><span class="pre">COUNTER_ENABLE_EVENTS_IOCTL</span></code></p></li>
<li><p><code class="xref c c-macro docutils literal notranslate"><span class="pre">COUNTER_DISABLE_EVENTS_IOCTL</span></code></p></li>
</ul>
<p>To configure events to gather Counter data, users first populate a
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_watch</span></code> with the relevant event id, event channel id,
and the information for the desired Counter component from which to
read, and then pass it via the <code class="docutils literal notranslate"><span class="pre">COUNTER_ADD_WATCH_IOCTL</span></code> ioctl
command.</p>
<p>Note that an event can be watched without gathering Counter data by
setting the <code class="docutils literal notranslate"><span class="pre">component.type</span></code> member equal to
<code class="docutils literal notranslate"><span class="pre">COUNTER_COMPONENT_NONE</span></code>. With this configuration the Counter
character device will simply populate the event timestamps for those
respective <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_event</span></code> elements and ignore the component
value.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">COUNTER_ADD_WATCH_IOCTL</span></code> command will buffer these Counter
watches. When ready, the <code class="docutils literal notranslate"><span class="pre">COUNTER_ENABLE_EVENTS_IOCTL</span></code> ioctl command
may be used to activate these Counter watches.</p>
<p>Userspace applications can then execute a <code class="docutils literal notranslate"><span class="pre">read</span></code> operation (optionally
calling <code class="docutils literal notranslate"><span class="pre">poll</span></code> first) on the Counter character device node to retrieve
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">counter_event</span></code> elements with the desired data.</p>
</section>
</section>
</section>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="memory-devices/index.html" class="btn btn-neutral float-right" title="Memory Controller drivers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="io_ordering.html" class="btn btn-neutral float-left" title="Ordering I/O writes to memory-mapped addresses" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright The kernel development community.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>